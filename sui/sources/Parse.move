// Parse/Serialization helpers generated by Copilot.

module Wormhole::Parse {
    use 0x1::Option;
    use 0x1::Vector;

    // Pop from the front of the list by swapping the first element with the last element.
    // Then swapping again to fix order.
    //
    // Ownership analysis is applied to arguments left to right, so the following snippet is
    // rejected by Move right:
    //
    // ```move
    // Vector::swap(v, 0, length(v) - 1);
    // ```
    //
    // This is beacuse the checker things v was borrowed even though Move could evaluate length(v)
    // first. I assume the compiler is not smart enough to re-order this yet.
    public fun pop_front<E>(v: &mut Vector<E>): E {
        let e = Vector::swap_remove(v, 0);
        let l = Vector::length(v);
        Vector::swap(v, 0, l - 1);
        return e;
    }

    public fun parse_u8(bytes: vector<u8>): (u8, vector<u8>) {
        let byte = pop_front(&mut bytes);
        (byte, bytes)
    }

    public fun parse_u16(bytes: vector<u8>): (u32, vector<u8>) {
        let (byte1, bytes) = parse_u8(bytes);
        let (byte2, bytes) = parse_u8(bytes);
        ((byte1 as u32) << 8 | (byte2 as u32), bytes)
    }

    public fun parse_u32(bytes: vector<u8>): (u32, vector<u8>) {
        let (byte1, bytes) = parse_u8(bytes);
        let (byte2, bytes) = parse_u8(bytes);
        let (byte3, bytes) = parse_u8(bytes);
        let (byte4, bytes) = parse_u8(bytes);
        ((byte1 as u32) << 24 | (byte2 as u32) << 16 | (byte3 as u32) << 8 | (byte4 as u32), bytes)
    }

    public fun parse_u64(bytes: vector<u8>): (u64, vector<u8>) {
        let (byte1, bytes) = parse_u8(bytes);
        let (byte2, bytes) = parse_u8(bytes);
        let (byte3, bytes) = parse_u8(bytes);
        let (byte4, bytes) = parse_u8(bytes);
        let (byte5, bytes) = parse_u8(bytes);
        let (byte6, bytes) = parse_u8(bytes);
        let (byte7, bytes) = parse_u8(bytes);
        let (byte8, bytes) = parse_u8(bytes);
        ((byte1 as u64) << 56 |
            (byte2 as u64) << 48 |
            (byte3 as u64) << 40 |
            (byte4 as u64) << 32 |
            (byte5 as u64) << 24 |
            (byte6 as u64) << 16 |
            (byte7 as u64) << 8 |
            (byte8 as u64), bytes)
    }

    public fun parse_u128(bytes: vector<u8>): (u128, vector<u8>) {
        let (byte1, bytes) = parse_u64(bytes);
        let (byte2, bytes) = parse_u64(bytes);
        ((byte1 as u128) << 64 | (byte2 as u128), bytes)
    }

    public fun parse_vector(bytes: vector<u8>, len: u64): (vector<u8>, vector<u8>) {
        let result = Vector::empty();
        while ({
            spec {
                invariant len >= 0;
                invariant len <  Vector::length(bytes);
            };
            len > 0
        }) {
            let (byte, r) = parse_u8(bytes);
            Vector::push_back(&mut result, byte);
            len = len - 1;
            bytes = r;
        };
        (result, bytes)
    }
}
